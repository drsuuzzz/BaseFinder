/* "$Id: SequenceEditor.m,v 1.5 2006/11/03 02:24:39 smvasa Exp $" */

/***********************************************************

Copyright (c) 1993-2000 Morgan Giddings, Jessica Severin, and Lloyd Smith 

All Rights Reserved.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.  Citations, discussions, and references to or regarding
this work in scholarly journals or other scholarly proceedings 
are exempted from this permission requirement.

Support for this work provided by:
The University of Wisconsin-Madison Chemistry Department
The National Institutes of Health/National Human Genome Research Institute
The Department of Energy


******************************************************************/

/* Generated by Interface Builder */

#import "SequenceEditor.h"
#import <GeneKit/Trace.h>
#import "SequenceView.h"
#import "MasterView.h"
#import "PrintView.h"
#import "PrintingOptions.h"
#import <GeneKit/NumericalRoutines.h>
#import <GeneKit/StatusController.h>
#import "LaneCountController.h"
#import "ViewOptions.h"
#import <BaseFinderKit/NewScript.h>
#import "BasesView.h"
#import <BaseFinderKit/NewScript.h>
#import <AppKit/NSApplication.h>
#import <AppKit/NSWindow.h>
#import <AppKit/NSMatrix.h>
#import <Foundation/NSUserDefaults.h>


#import <objc/objc.h>
#import <stdlib.h>
#import <string.h>
#import <limits.h>
#import <float.h>
#import <GeneKit/readABI.h>
#import <Foundation/NSByteOrder.h>

/****
* April 18, 1994: Removed should normalize routines. New print option to display the
* data ranges added. 
****/

id GSeqEdit=nil;

@implementation SequenceEditor

static void newLocation(NSPoint *p)
{
    static int count = 0;
    p->x += (20.0 * count);
    p->y -= (25.0 * count);
    count = (count > 10)? 0 : count+1;
}

+ (SequenceEditor*)activeSequenceEditor
{
  return GSeqEdit;
}

- (BOOL)debugMode
{
  return debugmode;
}

+ new
{		
  SequenceEditor     *newSelf;

  newSelf = [self alloc];
  [NSBundle loadNibNamed:@"SequenceView.nib" owner:newSelf];
  [newSelf init];
  return newSelf;
}

- (void)setupStatusView
{
  NSRect   scrollRect, statusFrame;
  NSSize   contentSize;

  scrollRect = [[myMasterView enclosingScrollView] frame];
  contentSize = [[myMasterView enclosingScrollView] contentSize];
  statusFrame = NSMakeRect(scrollRect.origin.x+scrollRect.size.width,
                           scrollRect.origin.y+scrollRect.size.height+5.0, 1.0, 1.0);
  
  statusDisplayer = [[UWStatusView alloc] initWithFrame:statusFrame];
  [statusDisplayer setAutoresizingMask:(NSViewMinXMargin | NSViewMinYMargin)];
  [statusDisplayer setAnchor:UWStatusLowerRight];
  [statusDisplayer setStatus:nil];
  [[theSequenceWindow contentView] addSubview:statusDisplayer positioned:NSWindowAbove relativeTo:nil];
}

- init
{		
  //NSRect theFrame;
  int    x;
    NSDictionary *defaultsDict = [NSDictionary dictionaryWithObjectsAndKeys:
    [NSNumber numberWithInt:4], @"NumberViews",
    [NSNumber numberWithInt:1], @"ViewPercent",  nil];


  //theFrame = [theSequenceWindow frame];
  //newLocation(&theFrame.origin);
  //[theSequenceWindow setFrameOrigin:NSMakePoint(theFrame.origin.x, theFrame.origin.y)];
  
  [[NSUserDefaults standardUserDefaults] registerDefaults:defaultsDict];

  
  backgroundColor = [NSColor whiteColor];

  for(x=0; x<8; x++)
    channelEnabled[x] = YES;

  [SequenceEditor setVersion:8];
  [multiLaneBoxID retain];
  [rawProcBoxID retain];
  laneFileObj = nil;

  GSeqEdit = self;  //newest SeqEdit is active (forNT)

  NS_DURING
    [theSequenceWindow setFrameUsingName:@"SequenceEditorWindow"];
    [theSequenceWindow display];
  NS_HANDLER
    NSLog(@"something is wrong with the nib, but I can't figure it out");
  NS_ENDHANDLER
    
  [theSequenceWindow setFrameAutosaveName:@"SequenceEditorWindow"];
  //[theSequenceWindow display];
  //[theSequenceWindow orderFront:self];

  [self setupStatusView];
  [[NSNotificationCenter defaultCenter] addObserver:self
                                           selector:@selector(updateScriptStatus:)
                                               name:@"BFScriptStatusChanged"
                                             object:nil];
  statusTimer = [NSTimer scheduledTimerWithTimeInterval:0.1
                                   target:self
                                 selector:@selector(updateScriptStatusDisplay)
                                 userInfo:nil
                                  repeats:YES];
  statusNeedsDisplay = NO;
	channelSplit = 2;
  return self;
}

- (void)show:sender
{
  [theSequenceWindow orderFront:self]; 
}

- (void)hide:sender
{
  [theSequenceWindow orderOut:self];
}


- (void)windowDidBecomeKey:(NSNotification *)notification
{	
  //NSWindow *theWindow = [notification object];
  if (debugmode) NSLog(@"window did become key");
  GSeqEdit = self;
  [[NSNotificationCenter defaultCenter]
      postNotificationName:@"BFSynchronizeScript" object:self];
  [theSequenceWindow setAcceptsMouseMovedEvents:YES];
  [theSequenceWindow makeFirstResponder:myMasterView];
  [myMasterView resetTrackingRectToVisible];
  [NSApp updateWindows];
}

- (void)windowDidResignKey:(NSNotification *)notification 
{
  //NSWindow *theWindow = [notification object];
  if (debugmode) NSLog(@"window did resgn key");
  [theSequenceWindow setAcceptsMouseMovedEvents:NO];
  [myMasterView clearTrackingRect];
}

- (void)windowWillClose:(NSNotification *)notification
{
  /***
  GSeqEdit = nil;
  [[NSNotificationCenter defaultCenter]
      postNotificationName:@"BFSynchronizeScript" object:self];
  [self release];
  [theSequenceWindow setDelegate:nil]; // So it doesn't try to message freed delegate
	***/
}

- (void)windowDidResize:(NSNotification *)notification
{
  //NSWindow   *theWindow = [notification object];

  [myMasterView resetTrackingRectToVisible];
}

- (id)returnWindowID	
{
	return theSequenceWindow;
}

- setMasterViewToDefaults
{
  numViews = [[[NSUserDefaults standardUserDefaults] objectForKey:@"NumberViews"] intValue];
  viewPercent = [[[NSUserDefaults standardUserDefaults] objectForKey:@"ViewPercent"] floatValue];
  [myMasterView setActiveBases:255];
  [myMasterView boundToAll];
  [myMasterView changeNumViews:numViews :viewPercent];	/* causes a redraw */
  return self;
}


- setLanesFile:(LanesFile *)thisLaneFileObject
{	
  NSString   *type;

  if(laneFileObj != NULL) {
    [[laneFileObj activeScript] setIsActive:NO];
    [laneFileObj release];
  }

  laneFileObj = [thisLaneFileObject retain];
  if(laneFileObj == NULL) return self;
  
  type = [[[laneFileObj fileName] pathExtension] uppercaseString];
  
  if([type isEqualToString:@"LANES"]) {
    [numLanesID setIntValue:[laneFileObj numLanes]];
    [laneNumID setIntValue:1];
    [laneFileObj switchToLane:1]; // Forces a load
    [[[laneFileObj activeScript] rawData] setDefaultRawLabels];
  }
  [[laneFileObj activeScript] setIsActive:YES];

  [self setDefaultColors];
  [myMasterView setColorWells];
  [self setFileName:[laneFileObj fileName]];
  if([type isEqualToString:@"LANES"]) [self switchToMultiLane:YES];
  else [self switchToMultiLane:NO];

  [self setMasterViewToDefaults]; //causes redraw

  if (debugmode) fprintf(stderr, "SHOWSELF DONE\n");
  statusNeedsDisplay = YES;
  [self updateScriptStatusDisplay];
  return self;

}

- (LanesFile *)lanesFile { return laneFileObj; }

- (void)setFileName:(NSString*)aName
{
  if(fileName != nil)
    [fileName release];

  fileName = [aName copy];
  [theSequenceWindow setTitleWithRepresentedFilename:fileName];
}

- (NSString*)fileName { return fileName; }
- (int)numberChannels { return [[self pointStorageID] numChannels]; }
- (unsigned int)numberPoints { return [[self pointStorageID] length]; }
- (id)masterViewID { return myMasterView; }

- (void)printSelf
{
  float             minY[8], maxY[8];
  PrintView         *myPrintView;
  NSPrintOperation  *thisPrintOperation;
  PrintingOptions   *myPrintOptions;


  myPrintOptions = [PrintingOptions new];
  [myPrintOptions prepareToPrint];
  myPrintView = [PrintView new];		//creates view fitted to printable area

  [myPrintView setOwner:self];
  [myMasterView getDataMin:minY max:maxY];
  [myPrintView setDataMin:minY max:maxY];
  [myPrintView setActiveBases:[myMasterView activeBases]];

  [[printWindow contentView] addSubview:myPrintView];
  thisPrintOperation = [NSPrintOperation printOperationWithView:myPrintView];
  [thisPrintOperation setAccessoryView:[myPrintOptions accessoryView]];
  [thisPrintOperation runOperation];

  //[myPrintView print:self];

  [myPrintView removeFromSuperview];
  [myPrintOptions release];
}

- (Sequence*)baseStorageID
{
  return [[self currentScript] currentBases];
}

- (Sequence*)alnBaseStorageID
{
  return [[self currentScript] currentAlnBases];
}

-(AlignedPeaks*)peakListStorageID
{
  return [[self currentScript] currentPeakList];
}

- (Trace*)pointStorageID
{
  return [[self currentScript] currentData];
}

- (Trace*)trace
{
  return [[self currentScript] currentData];
}


- (EventLadder*)currentLadder
{
  return [[self currentScript] currentLadder];
}

- (void)shouldRedraw
{
  if ([self baseStorageID]!=nil) {
    //[viewOptionsID parseLabels];
  }
  [myMasterView resetBounds];		// recalcs view normalization
  [myMasterView shouldRedraw];
}

- (NSColor *)backgroundColor
{
  if([theSequenceWindow canStoreColor]) return backgroundColor;
  else return [NSColor whiteColor];
}

- (void)setBackgroundColor:(NSColor *)thisColor
{
  backgroundColor = thisColor;
  [myMasterView setBackgroundColor:thisColor];
}

- (void)setCurrentScript:(NewScript*)theScript
{
  [laneFileObj applyScript:theScript];
  [[laneFileObj activeScript] setIsActive:YES];
}


- (NewScript*)currentScript
{
  return [laneFileObj activeScript];
}

- (LanesFile*)dataManager
{
  return laneFileObj;
}

/*****
*
* Section for dealing with changing lanes in a .lanes file
*
******/
- (void)switchToMultiLane:(BOOL)value
{
  //switches the Box in the upper right of the sequence window
  //between the multi-lane box & the raw/processed box
  NSRect   tempRect;

  if(value) { //multi-lane
    if (debugmode) fprintf(stderr,"switch to multi-lane\n");
    if([[[theSequenceWindow contentView] subviews] indexOfObjectIdenticalTo:multiLaneBoxID] == NSNotFound) {
      tempRect = [rawProcBoxID frame];
      [multiLaneBoxID setFrameOrigin:NSMakePoint(tempRect.origin.x, tempRect.origin.y)];
      [rawProcBoxID removeFromSuperview];
      [[theSequenceWindow contentView] addSubview:multiLaneBoxID
                                       positioned:NSWindowBelow
                                       relativeTo:statusDisplayer];

    }
  }
  else { // empty (uses an empty NSBox to hold the place)
    if (debugmode) fprintf(stderr,"switch to raw/proc\n");
    if([[[theSequenceWindow contentView] subviews] indexOfObjectIdenticalTo:rawProcBoxID] == NSNotFound) {
      tempRect = [multiLaneBoxID frame];
      [rawProcBoxID setFrameOrigin:NSMakePoint(tempRect.origin.x, tempRect.origin.y)];
      [multiLaneBoxID removeFromSuperview];
      [[theSequenceWindow contentView] addSubview:rawProcBoxID
                                       positioned:NSWindowBelow
                                       relativeTo:statusDisplayer];
    }
  }
}

- (void)ORIGswitchToMultiLane:(BOOL)value
{
  //switches the Box in the upper right of the sequence window
  //between the multi-lane box & the raw/processed box
  NSRect   tempRect;

  if(value) { //mulit-lane
   if (debugmode) printf("switch to multi-lane\n");
    if([[[theSequenceWindow contentView] subviews] indexOfObjectIdenticalTo:multiLaneBoxID] == NSNotFound) {
      tempRect = [rawProcBoxID frame];
      [multiLaneBoxID setFrameOrigin:NSMakePoint(tempRect.origin.x, tempRect.origin.y)];
      [rawProcBoxID removeFromSuperview];
      [[theSequenceWindow contentView] addSubview:multiLaneBoxID];
    }
  }
  else { // raw/processed (ie ABI or SCF file format)
   if (debugmode) printf("switch to raw/proc\n");
    if([[[theSequenceWindow contentView] subviews] indexOfObjectIdenticalTo:rawProcBoxID] == NSNotFound) {
      tempRect = [multiLaneBoxID frame];
      [rawProcBoxID setFrameOrigin:NSMakePoint(tempRect.origin.x, tempRect.origin.y)];
      if([laneFileObj numLanes] < 2) {
        //no processed data
        [[rawProcSelectorID cellAtRow:1 column:0] setEnabled:NO];
      }
      else {
        [[rawProcSelectorID cellAtRow:1 column:0] setEnabled:YES];
      }
      [multiLaneBoxID removeFromSuperview];
      [[theSequenceWindow contentView] addSubview:rawProcBoxID];
    }
  }
}

- (BOOL)switchToLane:(int)value
{
  if(laneFileObj == NULL) return NO;

  if (value==[laneFileObj activeLane])
    return YES;
		
  [laneFileObj switchToLane:value];

  [laneNumID setIntValue:[laneFileObj activeLane]];
  if (debugmode) printf(" after laneObject switchToLane %d\n", value);
  [[NSNotificationCenter defaultCenter]
            postNotificationName:@"BFSynchronizeScriptAndTools" object:self];

  [self shouldRedraw];
  //	[self show:self];
  return YES;
}

- (void)switchRawProc:sender
{
  [self switchToLane:[rawProcSelectorID selectedRow]+1];
}

- (void)increaseLaneNumber:sender;
{
  int activeLane = [laneFileObj activeLane];

  if(activeLane < [laneFileObj numLanes])
    [self switchToLane:activeLane+1];
}

- (void)decreaseLaneNumber:sender;
{
  int activeLane = [laneFileObj activeLane];

  if(activeLane > 1)
    [self switchToLane:activeLane-1];
}

- (void)changeLaneNumber:sender;
{
  int   newLane;
  int   numLanes = [laneFileObj numLanes];

  newLane = [laneNumID intValue];
  if(newLane < 1) newLane=1;
  if(newLane > numLanes) newLane = numLanes;
  [laneNumID setIntValue:newLane];
  [self switchToLane:newLane];
}

- (int)currentLane { return [laneFileObj activeLane]; }
- (int)numLanes {return [laneFileObj numLanes]; }

/******
*
* display attributes section
*
*******/

- (BOOL)channelEnabled:(int)channel
{
  if(channel<0) return FALSE;
  if(channel>[self numberChannels]) return FALSE;
  return channelEnabled[channel];
}

- (BOOL)setEnabled:(BOOL)value channel:(int)channel
{
  if(channel<0) return NO;
  if(channel>[self numberChannels]) return NO;
  channelEnabled[channel] = value;
  return YES;
}

- (NSColor *)channelColor:(int)channel
{
  if(channel<0) return [NSColor blackColor];
  if(channel>[self numberChannels]) return [NSColor blackColor];
  return channelColor[channel];
}

- (BOOL)setColor:(NSColor *)color channel:(int)channel
{
  if(channel<0) return NO;
  if(channel>[self numberChannels]) return NO;
  channelColor[channel] = color;
  return YES;
}

- (void)setDefaultColors
{
  if([theSequenceWindow canStoreColor]) {
    channelColor[0] = [NSColor blueColor];
    channelColor[1] = [NSColor greenColor];
    channelColor[2] = [NSColor blackColor];
    channelColor[3] = [NSColor redColor];
		channelColor[4] = [NSColor cyanColor];
		channelColor[5] = [NSColor purpleColor];
		channelColor[6] = [NSColor orangeColor];
		channelColor[7] = [NSColor grayColor];
  }
  else {
    channelColor[0] = [NSColor blackColor];
    channelColor[1] = [NSColor darkGrayColor];
    channelColor[2] = [NSColor grayColor];
    channelColor[3] = [NSColor lightGrayColor];
		channelColor[4] = [NSColor blackColor];
		channelColor[5] = [NSColor darkGrayColor];
		channelColor[6] = [NSColor grayColor];
		channelColor[7] = [NSColor lightGrayColor];
  }
}

/*****
*
* New status display, ala OmniWeb 3 (kind of)
*
*****/

- (void)updateScriptStatus:(NSNotification *)notification
{
  //method should be thread safe since notification will be posted from other thread
  NewScript *aScript = [notification object];

  if(aScript != [self currentScript]) {
    statusNeedsDisplay = NO;
    return;
  }
  if([aScript statusMessage] != nil)
    if(debugmode) fprintf(stderr, "status: %s, %f\n", [[aScript statusMessage] cString], [aScript statusPercent]);

  statusNeedsDisplay = YES;

  if(![[NSUserDefaults standardUserDefaults] boolForKey:@"useForgroundThreading"]) {
    [self updateScriptStatusDisplay];
    [[statusDisplayer superview] display];
  }
}

- (void)updateScriptStatusDisplay
{
  //called by Timer in AppKit thread.
  //used to disconnect statusUpdate message between threads
  NewScript *aScript;

  if(!statusNeedsDisplay) return;
  aScript = [self currentScript];
  
  if([aScript statusMessage] == nil) {
    [statusDisplayer setStatus:nil];
    statusNeedsDisplay = NO;
    //fprintf(stderr, "status cleared\n");
    return;
  }
  if([aScript statusPercent] <= 0.0) {
    [statusDisplayer setStatus:[aScript statusMessage]];
  }
  else {
    [statusDisplayer setStatus:[aScript statusMessage]
             withProgress:(int)[aScript statusPercent]
                  ofTotal:100];
  }

  statusNeedsDisplay = NO;
  //fprintf(stderr, "status updated\n");
}


@end
