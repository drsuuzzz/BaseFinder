/* "$Id: SequenceView.m,v 1.24 2007/06/13 15:28:56 smvasa Exp $" */

/***********************************************************

Copyright (c) 1992-2000 Morgan Giddings, Jessica Severin, and Lloyd Smith 

All Rights Reserved.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.  Citations, discussions, and references to or regarding
this work in scholarly journals or other scholarly proceedings 
are exempted from this permission requirement.

Support for this work provided by:
The University of Wisconsin-Madison Chemistry Department
The National Institutes of Health/National Human Genome Research Institute
The Department of Energy


******************************************************************/

/* Generated by Interface Builder */

#import "SequenceView.h"
#import "MasterView.h"
#import <GeneKit/NumericalRoutines.h>
#import "SequenceEditor.h"
#import <Foundation/NSUserDefaults.h>
//#import <GeneKit/UserPath.h>
#import <math.h>
#import <stdlib.h>
#import <string.h>
#import <float.h>

@interface SequenceView (Private)
- (void)drawWithoutUserPaths:(NSRect)aRect;
- (void)drawWithBezier:(NSRect)aRect;
- (void)drawLadder:(NSRect)aRect; 
- (BOOL)drawBases:(float)xscale :(int)startpoint :(int)endpoint :(int)numChannels :(float)yOrigin;
- (void)drawDataMarkers:(int)startOffset;
- (BOOL)drawBaseNumbers;
- (void)drawPeaks:(NSRect)aRect;
- (BOOL) peakIntersects:(int)index :(int)first :(int)last;
@end



@implementation SequenceView
#define BASEFONTSIZE 8

- (void)selectPeak:(NSPoint)ourPoint
{
	NSRect       imageRect;
	int          i,j;
	NSDictionary *peakPtDict;
	BOOL         found, decrease;
  AlignedPeaks *peakInds = [seqEditor peakListStorageID];
  Trace        *trace = [seqEditor trace];
  NSRect       selfrect = [self bounds];
  float        yscale, tempoffset=0, tempheight=0;  
  int          viewType;
  float        y,y_1,y0,y1,tempy,x,foundx,foundy;
  float        mag_1,mag0,mag1,tempmag;
	
	if (peakInds == nil) return;
  found = NO;
  viewType = [[[NSUserDefaults standardUserDefaults] objectForKey:@"SplitView"] intValue];
	for (i=0; i < [peakInds length]; i++) {
		for (j=0; j < 4; j++) {
			if ([peakInds hasOrigin:i :j]) {
				imageRect.origin = [peakInds originAt:i :j];
				imageRect.size = [handleImage size];
				if (NSPointInRect(ourPoint,imageRect)) {
					peakPtDict = [NSDictionary dictionaryWithObjectsAndKeys:
              [NSNumber numberWithInt:([peakInds valueAt:i :j]+[trace deleteOffset])], @"value",
																	[NSNumber numberWithInt:j], @"channel",
																	nil];
					[[NSNotificationCenter defaultCenter] postNotificationName:@"PeakPtHit" 
																													object:nil 
																												userInfo:peakPtDict];
					found = YES;
				}//if point in rectangle
			}
		} //for j
	} //for i
		
	if (!found) {
    imageRect.size = [handleImage size];
    ourPoint.x = [self pointNumber:ourPoint.x];
    for (i=0; i < 4; i++) {
      if ((maxY[i] - minY[i])< 1.0e-6)
        yscale = 1.0;
      else
        yscale = (selfrect.size.height-(1.0+yOrigin))/(maxY[i] - minY[i]);
      if (yscale <= 0.0)
        return;
      if (yScale >= 0)
        yscale = yscale * yScale;
      switch (viewType) {
        case 2:   //all
          tempoffset = 0;
          tempheight = 0;
          break;
        case 1:		//dual
          if (i > 1) {
            tempoffset = 0;
            tempheight = selfrect.size.height/2;
          }
          else {
            tempoffset = selfrect.size.height/2;
            tempheight = 0;
          }
          break;
        case 0:  //single
                 //tempheight = tempoffset;
          tempoffset = (selfrect.size.height/4)*(3-i);
          tempheight = (selfrect.size.height/4)*(i);
          break;
      }
      y = ourPoint.y;
      x = ourPoint.x;
      y_1 = (float)(([trace sampleAtIndex:(x-1) channel:i]-minY[i])*yscale + yOrigin + tempoffset);
      y0 = (float)(([trace sampleAtIndex:x channel:i]-minY[i])*yscale + yOrigin + tempoffset);
      y1 = (float)(([trace sampleAtIndex:(x+1) channel:i]-minY[i])*yscale + yOrigin + tempoffset);
      mag_1 = sqrtf(1 + (y-y_1)*(y-y_1));
      mag0 = fabs(y-y0);
			foundx = x;
			foundy = y0;
      mag1 = sqrtf(1+(y-y1)*(y-y1));
      if ((mag0 < mag_1) && (mag0 < mag1)) { //smallest distance from line
        tempy = (float)(([trace sampleAtIndex:x channel:i]-minY[i])*yscale + yOrigin + tempoffset);
      } 
      else {
        if (mag_1 < mag0)
          decrease = YES;
        else
          decrease = NO;
        found = NO;
        while (!found && (x > 0) && (x < [trace length]-1)) {
          if (decrease)
            x--;
          else
            x++;
          tempy = (float)(([trace sampleAtIndex:x channel:i]-minY[i])*yscale + yOrigin + tempoffset);
          tempmag = sqrtf((x-ourPoint.x)*(x-ourPoint.x) +
                          (y-tempy)*(y-tempy));
          if (tempmag <= mag0) {
						mag0 = tempmag;
						foundx = x;
						foundy = tempy;
					}
          else
            found = YES;
        }            
      }
      imageRect.origin.x = foundx - [handleImage size].width/2;
      imageRect.origin.y = foundy - [handleImage size].height/2;
      if (NSPointInRect(ourPoint,imageRect)) {
        peakPtDict = [NSDictionary dictionaryWithObjectsAndKeys:
                                      [NSNumber numberWithInt:(x+[trace deleteOffset])], @"value",
                                      [NSNumber numberWithInt:i], @"channel",
                                                                nil];
        [[NSNotificationCenter defaultCenter] postNotificationName:@"PeakPtHit" 
                                                            object:nil 
                                                          userInfo:peakPtDict];
        break;
        
      }
    } //for
	} //if 												
}

- (BOOL) peakIntersects:(int)index :(int)first :(int)last
{
	int          value, value2, value3, value4;
  int          begin, end;
	BOOL         intersects=NO;
  AlignedPeaks *peakInds = [seqEditor peakListStorageID];
	
  begin = first-1 - [handleImage size].width/2;
  end = last+1 + [handleImage size].width/2;
  begin = (begin < 0) ? 0 : begin;
  
  value = [peakInds valueAt:index :0];
  value2 = [peakInds valueAt:index :1];
  value3 = (([peakInds valueAt:index :2] > 0 ) ? [peakInds valueAt:index :2] : -[peakInds valueAt:index :2]);
  value4 = (([peakInds valueAt:index :3] > 0 ) ? [peakInds valueAt:index :3] : -[peakInds valueAt:index :3]);
  if (((value <= end) && (value >= begin)) ||
      ((value2 <= end) && (value2 >= begin)) ||
      ((value3 <= end) && (value3 >= begin)) ||
      ((value4 <= end) && (value4 >= begin)))
    intersects=YES;
  else 
    intersects=NO;
    
	return intersects;
}

- (void)drawPeaks:(NSRect)aRect
{
    Trace *trace = [seqEditor trace];
    AlignedPeaks *peakInds = [seqEditor peakListStorageID];
    unsigned    channel;
    float       bbox[4], yscale, tempoffset=0, tempheight=0; 
    NSRect      selfrect = [self bounds];
		int					start, end;
		int					i,max;
		int					value;
		BOOL				flag=NO;
    int         viewType;
		

    if (trace == NULL)
        return;
      if (peakInds == nil)
				return;
      bbox[0] = selfrect.origin.x;
      bbox[1] = selfrect.origin.y;
      bbox[2] = selfrect.origin.x+selfrect.size.width;
      bbox[3] = selfrect.origin.y+selfrect.size.height;
			start = ((aRect.origin.x / xScale) + startPoint)-1;
			end = (((aRect.origin.x + aRect.size.width)/xScale) + 		
                    startPoint)+1;
			if (start < startPoint)
				start = startPoint;
			if (end > endPoint)
        end = endPoint;
      viewType = [[[NSUserDefaults standardUserDefaults] objectForKey:@"SplitView"] intValue];
			for (i = 0; i < [peakInds length]; i++) {
				if ([self peakIntersects:i :start :end]) {
          NSBezierPath *path = [NSBezierPath bezierPath];
          NSPoint			pt;	
          if ([trace numChannels] > 4)
            max = 4;
          else
            max = [trace numChannels];
					for (channel = 0; channel < max; channel ++)
						if ([seqEditor channelEnabled:channel]) {
              
							[path setLineWidth:0.5];
							[[NSColor blackColor] set];
							if ((maxY[channel] - minY[channel])< 1.0e-6)
									yscale = 1.0;
							else
									yscale = (selfrect.size.height-(1.0+yOrigin))/(maxY[channel] -
                                                            minY[channel]);
							if (yscale <= 0.0)
									return;
							if (yScale >= 0)
								yscale = yscale * yScale;
							switch (viewType) {
							case 2:   //all
								tempoffset = 0;
								tempheight = 0;
								break;
							case 1:		//dual
								if (channel > 1) {
									tempoffset = 0;
									tempheight = selfrect.size.height/2;
								}
								else {
									tempoffset = selfrect.size.height/2;
									tempheight = 0;
								}
								break;
							case 0:  //single
								//tempheight = tempoffset;
								tempoffset = (selfrect.size.height/4)*(3-channel);
								tempheight = (selfrect.size.height/4)*(channel);
								break;
							}
              value = [peakInds valueAt:i :channel];
							if (value < 0) {  //draw open square
								flag = YES;
								value = -value;
							}
							switch (channel) {  //draw open square if unaligned.
							case 0:
								if (([peakInds valueAt:i :1] == 0) && ([peakInds valueAt:i :2] == 0) &&
										([peakInds valueAt:i :3] == 0))
									flag = YES;
								break;
							case 1:
								if (([peakInds valueAt:i :0] == 0) && ([peakInds valueAt:i :2] == 0) &&
										([peakInds valueAt:i :3] == 0))
									flag = YES;
								break;
							case 2:
								if (([peakInds valueAt:i :1] == 0) && ([peakInds valueAt:i :0] == 0) &&
										([peakInds valueAt:i :3] == 0))
									flag = YES;
								break;
							case 3:
								if (([peakInds valueAt:i :1] == 0) && ([peakInds valueAt:i :2] == 0) &&
										([peakInds valueAt:i :0] == 0))
									flag = YES;
								break;
							}
							pt.x = (float)(value-startPoint) * xScale;
							pt.y = (float)(([trace sampleAtIndex:value channel:channel]-minY[channel])*yscale + yOrigin + tempoffset);
							if (value != 0)
						//		if (!((pt.x < bbox[0]) || (pt.x > bbox[2]))) 
                {
									NSRect	imageRect;
																		
									if(pt.y < bbox[1]) pt.y=bbox[1];
									if(pt.y > bbox[3]-tempheight) pt.y=bbox[3]-tempheight;
									if (channel == 0)
										[path moveToPoint:pt]; 
									else
										[path lineToPoint:pt]; 
									pt.x = pt.x - [handleImage size].width/2;
									if ((pt.y + [handleImage size].height) > (bbox[3]-tempheight)) 
										pt.y = bbox[3] - tempheight - [handleImage size].height;
									imageRect.origin = NSZeroPoint;
									imageRect.size = [handleImage size];
                  [peakInds addOrigin:i :channel :pt];
                  if (flag)
										[handleImage2 drawAtPoint:pt
																	 fromRect:imageRect
																	operation:NSCompositeSourceOver
																	 fraction:0.8];
									else
										[handleImage drawAtPoint:pt
																	fromRect:imageRect
																 operation:NSCompositeSourceOver
																	fraction:0.8];
									flag = NO;
								}
					} //if seqEditor
        [path stroke];
				}//if end < value < start
    }//for starti
}


- (BOOL)drawBases:(float)xscale :(int)startpoint :(int)endpoint :(int)numChannels :(float)yorigin
{
  int           i, j, baseCount;
  NSRect        mybounds;
  float         temp=0;
  float         lineto;
  int           activeBases, mask=0;		/* a bit mask of active channels */
  NSColor       *tempColor;
  Sequence      *baseList, *alignList;
  AlignedPeaks  *peakList;
  MasterView    *myMasterView = (MasterView *)[self superview];
  NSBezierPath *lines = [NSBezierPath bezierPath];
  NSPoint p;
  NSMutableDictionary *stringAttributes;
  int startBase, endBase;
  NSFont        *tempFont;
	int						someLines;

  baseList = [seqEditor baseStorageID];
  alignList = [seqEditor alnBaseStorageID];
  peakList = [seqEditor peakListStorageID];
  startpoint -= 8; endpoint +=8;
  if (startpoint < startPoint)
    startpoint = startPoint;
  if (endpoint > endPoint)
    endpoint = endPoint;
    
  if (baseList == NULL) {
    return NO;
  }
  tempFont = [NSFont fontWithName:@"Arial" size:8];
  stringAttributes= [NSMutableDictionary dictionaryWithObjectsAndKeys:tempFont, NSFontAttributeName, nil];
	if (alignList != nil)
		activeBases = 255;  //want to show all bases not just for active channels
	else
		activeBases = [myMasterView activeBases];
  if(activeBases==0) return YES;
		
  baseCount = [baseList seqLength];

  for (startBase = 0;
       ((startBase<baseCount)&&([[baseList baseAt:startBase] location]<startpoint));
       startBase++) {};
  for (endBase = 0;
       ((endBase<baseCount)&&([[baseList baseAt:endBase] location]<=endpoint));
       endBase++) {};
  if (startBase == baseCount) startBase = baseCount-1;
  else if (startBase > baseCount) startBase = baseCount;
  if (endBase > baseCount) endBase = baseCount;

  mybounds = [self bounds];
	someLines = [[[NSUserDefaults standardUserDefaults] objectForKey:@"BaseLines"] intValue];
  for (i = startBase; i < endBase; i++) {
    j = [[baseList baseAt:i] channel];
		if (j < -1) j = 0;
    mask = (int)pow(2,j+1);
    if(mask&activeBases) {
      temp=0.0;
      [lines setLineWidth:0.5];
      [[NSColor blackColor] set];
      temp = ([[baseList baseAt:i] location]-startPoint)*xscale;
      p.x = temp; p.y = yorigin-2;
			if ((peakList == nil) && someLines) {  
				lineto = mybounds.size.height/8 + yorigin;
				[lines moveToPoint:p];
				if([[[baseList baseAt:i] valueForKey:@"gapFill"] boolValue]) 
					p.y = lineto+20;
				else 
					p.y = lineto;
				[lines lineToPoint:p];
			}
			p.y = yorigin-BASEFONTSIZE - 8;
			p.x -= 3.5;
			if([[self window] canStoreColor]) {
				if(j==-1) 	/* gold for the N's */
					tempColor = [NSColor colorWithCalibratedRed:238.0/255.0 green:187.0/255.0 blue:34.0/255.0 alpha:1.0];
				else tempColor = [seqEditor channelColor:j];
			}
				else tempColor = [NSColor blackColor];
			[stringAttributes setObject:tempColor forKey:NSForegroundColorAttributeName];
  //      [tempColor set];
			[[[baseList baseAt:i] strBase] drawAtPoint:p withAttributes:stringAttributes];
		}
	}
	if ((peakList == nil) && someLines)
		[lines stroke]; 
  if (alignList == nil) return YES;
		baseCount = [alignList seqLength];
		for (startBase = 0;
				 ((startBase<baseCount)&&([[alignList baseAt:startBase] location]<startpoint));
				 startBase++) {};
		for (endBase = 0;
				 ((endBase<baseCount)&&([[alignList baseAt:endBase] location]<=endpoint));
				 endBase++) {};
    if (startBase == baseCount) startBase = baseCount-1;
    else if (startBase > baseCount) startBase = baseCount;
    if (endBase > baseCount) endBase = baseCount;
		for (i = startBase; i < endBase; i++) {
			j = [[alignList baseAt:i] channel];
			if (j < -1) j = 0;
			mask = (int)pow(2,j+1);
			if(mask&activeBases) {
				temp=0.0;
				[[NSColor blackColor] set];
				temp = ([[alignList baseAt:i] location]-startPoint)*xscale;
				p.x = temp;
				p.y = yorigin-0.5*BASEFONTSIZE - 5;
				p.x -= 3.5;
				if([[self window] canStoreColor]) {
					if(j==-1) 	/* gold for the N's */
						tempColor = [NSColor colorWithCalibratedRed:238.0/255.0 green:187.0/255.0 blue:34.0/255.0 alpha:1.0];
					else tempColor = [seqEditor channelColor:j];
				}
				else tempColor = [NSColor blackColor];
				[stringAttributes setObject:tempColor forKey:NSForegroundColorAttributeName];
				[[[alignList baseAt:i] strBase] drawAtPoint:p withAttributes:stringAttributes];
			}
		}
  return YES;
}


- (void)drawDataMarkers:(int)startOffset
{
	int					 x;
	NSRect			 boundsRect;
	float				 w1=100.0;
	id					 tempFont;
	NSDictionary *stringAttributes;
	NSString		 *dispString;
	NSBezierPath *path = [NSBezierPath bezierPath];
	NSPoint			 p, rp;
        	
	boundsRect = [self bounds];
	[[NSColor blackColor] set];
	tempFont = [NSFont userFontOfSize:9.0];
	stringAttributes= [NSDictionary dictionaryWithObjectsAndKeys:tempFont, NSFontAttributeName, nil];
	dispString = [NSString stringWithFormat:@"%dpts", endPoint+startOffset];
	w1 = [tempFont widthOfString:dispString];
	rp.x = 0; rp.y = -10.0;
	for(x=startPoint;x<endPoint;x++) {
		if(x%1000 == 0) {
			p.x = (x-startPoint)*xScale + 0.5; 
			p.y = boundsRect.size.height;
			rp.y = -10.0;
			[path moveToPoint:p];
			[path relativeLineToPoint:rp];
			p.x = (x-startPoint)*xScale + 1.5;
			p.y = boundsRect.size.height-14.0;
			dispString = [NSString stringWithFormat:@"%dpts", startOffset+x];
			[dispString drawAtPoint:p withAttributes:stringAttributes];
		}
		else if(x%100 == 0) {
			p.x = (x-startPoint)*xScale + 0.5; 
			p.y = boundsRect.size.height;
			rp.y = -10.0;
			[path moveToPoint:p];
			[path relativeLineToPoint:rp];                     
			if(w1<75*xScale) {
				dispString = [NSString stringWithFormat:@"%dpts", startOffset+x];
				p.x = (x-startPoint)*xScale + 1.5;
				p.y = boundsRect.size.height-14.0;
				[dispString drawAtPoint:p withAttributes:stringAttributes];
			}
		}
	}
	[path stroke];
}

- (BOOL)drawBaseNumbers
{
  int        	x;
  NSRect     	boundsRect;
  float      	w1=100.0, tempPos;
  NSFont    	*tempFont;
  Sequence   	*baseList = [seqEditor baseStorageID];
  Base       	*tBase;
  NSString 	*dString;
  NSPoint 	p, rp;
  NSBezierPath *path = [NSBezierPath bezierPath];
  NSDictionary *stringAttributes;
  int startBase, endBase, baseCount;
	int					offset, num;
	BOOL				backwards;
  
  if (baseList == NULL) return NO;
  [[NSColor blackColor] set];
  //tempFont= [NSFont fontWithName:@"Helvetica" size:8.0];
  tempFont = [NSFont userFontOfSize:9.0];
//  [tempFont set];
  stringAttributes= [NSDictionary dictionaryWithObjectsAndKeys:tempFont, NSFontAttributeName, nil];
  boundsRect = [self bounds];
  baseCount = [baseList seqLength];
	offset = [baseList getOffset];
	backwards = [baseList getbackForwards];
  for (startBase = 0;
       ((startBase<baseCount)&&([[baseList baseAt:startBase] location]<startPoint));
       startBase++) {};
  for (endBase = 0;
       ((endBase<baseCount)&&([[baseList baseAt:endBase] location]<=endPoint));
       endBase++) {};

  if (startBase >= endBase) return YES;
  if ((startBase < 0) || (startBase >= (baseCount - 1))) return YES;
  if (endBase < 0) return YES;
  if (endBase > baseCount) endBase = baseCount;
  dString = [NSString stringWithFormat:@"%d",endBase];
  w1 = [tempFont widthOfString:dString];
  rp.x = 0;
  for(x=startBase+1;x<=endBase; x++) {
    tBase = (Base *)[baseList baseAt:x-1];
    tempPos = ([tBase location]-startPoint)*xScale + 0.5;
		num = (offset > 0) ? x+offset-1 : x;
		if (backwards)
			num = offset+1-x;
    if(num%100 == 0) {
        rp.y = -10.0;
        dString = [NSString stringWithFormat:@"%d",num];
        p.x = tempPos+1.0; p.y = boundsRect.size.height-14.0;
        [dString drawAtPoint:p withAttributes:stringAttributes];
    }
    else if(num%10 == 0) {
        rp.y = -3.0;
      if(w1<75*xScale) {
        dString = [NSString stringWithFormat:@"%d",num];
        p.x = tempPos+1.0; p.y = boundsRect.size.height-14.0;
        [dString drawAtPoint:p withAttributes:stringAttributes];
      }
    }
    if (num%10 == 0) {
        p.x = tempPos;
        p.y = boundsRect.size.height;
        [path moveToPoint:p];
        [path relativeLineToPoint:rp];
    }
  }
    [path stroke];
    return YES;
}

- (BOOL)drawPhredCalls:(float)xscale :(int)startpoint :(int)endpoint :(float)yorigin
{
  //phredCalls is an NSArray of NSDictionaries
  //with the keys (baseCall, position, phredScore)
  int           channel, phredIndex;
  int           phredPos, phredScore;
  const char    *phredBase;
//  char          tempStr[32], tempStr2[8];
  NSRect        mybounds;
  float         temp=0;
  int           activeBases, mask=0;		/* a bit mask of active channels */
  NSColor       *tempColor;
  NSArray       *phredCalls;
  MasterView    *myMasterView = (MasterView *)[self superview];
  NSPoint p;
  NSString *phredBaseString, *scoreString;
  NSFont *tempFont;
  NSDictionary *stringAttributes;

  activeBases = [myMasterView activeBases];
  if(activeBases==0) return YES;

  phredCalls = [[[seqEditor pointStorageID] taggedInfo] objectForKey:@"phredCalls"];
  if (phredCalls == NULL) return NO;

  mybounds = [self bounds];
  tempFont = [[NSFontManager new] fontWithFamily:@"Ohlfs" traits:NSUnboldFontMask weight:0 size:9.0];
  stringAttributes= [NSDictionary dictionaryWithObjectsAndKeys:tempFont, NSFontAttributeName, nil];
  for(phredIndex=0; phredIndex<[phredCalls count]; phredIndex++) {
    phredPos = [[[phredCalls objectAtIndex:phredIndex] objectForKey:@"position"] intValue];
    phredScore = [[[phredCalls objectAtIndex:phredIndex] objectForKey:@"phredScore"] intValue];
    phredBase = [[[phredCalls objectAtIndex:phredIndex] objectForKey:@"baseCall"] cString];
    phredBaseString = [[phredCalls objectAtIndex:phredIndex] objectForKey:@"baseCall"];
    
    if((phredPos > startpoint) && (phredPos <= endpoint)) {
      switch (phredBase[0]) {
        case 'A': channel= 1; break;
        case 'C': channel= 0; break;
        case 'G': channel= 2; break;
        case 'T': channel= 3; break;
        case 'N': channel= -1; break;
        default: channel= -1;
      }
      mask = (int)pow(2,channel+1);
      if(mask&activeBases) {
        //get screen position for this base
        temp = (phredPos-startpoint)*xscale;

        //get color for this base
        if([[self window] canStoreColor]) {
          if(channel==-1)   // gold for the N's
            tempColor = [NSColor colorWithCalibratedRed:238.0/255.0
                                                  green:187.0/255.0
                                                   blue:34.0/255.0
                                                  alpha:1.0];
          else
            tempColor = [seqEditor channelColor:channel];
        }
        else
          tempColor = [NSColor blackColor];
        [tempColor set];
        p.x = -(BASEFONTSIZE/2.5/2)-1.0 + temp;
        p.y = yorigin-BASEFONTSIZE - 4;
        [phredBaseString drawAtPoint:p withAttributes:stringAttributes];
        if(phredScore < 10) [[NSColor redColor] set];
        else if(phredScore < 20) [[NSColor orangeColor] set];
        else if(phredScore < 30) [[NSColor colorWithCalibratedRed:0.0 green:0.33 blue:0.07 alpha:1.0] set];
        else if(phredScore < 40) [[NSColor blueColor] set];
        else [[NSColor purpleColor] set];

        scoreString = [NSString stringWithFormat:@"%2d", phredScore];
        p.x = -(BASEFONTSIZE/2.5/2)-1.0 + temp; p.y = yorigin-BASEFONTSIZE*2 - 4;
        [scoreString drawAtPoint:p withAttributes:stringAttributes];
      }
    }
  }
  return YES;
}


+ new
{
	id newInstance = [self alloc];
	[newInstance initWithFrame:NSZeroRect];
  return newInstance;
}

- initWithFrame:(NSRect)frameRect
{
	NSString   *tempPath;

  lastShiftX = -1;
  xScale = 0; yScale = -1;
  lastHighlightBase = -1;
  [super initWithFrame:frameRect];
  [self allocateGState];		/* for copying bitmaps */
  backColor = [NSColor whiteColor];
  selectRect = NSMakeRect(0, 0, 0, 0);
  highlightedBaseRect = NSMakeRect(0, 0, 0, 0);
	tempPath = [[NSBundle mainBundle] pathForResource:@"BFsmsq" ofType:@"tif"];
	handleImage = [[NSImage alloc] initWithContentsOfFile:tempPath];
	tempPath = [[NSBundle mainBundle] pathForResource:@"BFsmopen" ofType:@"tif"];
	handleImage2 = [[NSImage alloc] initWithContentsOfFile:tempPath];

  return self;
}

- (BOOL)isOpaque { return YES; }

- (void)setBackgroundColor:(NSColor *)theColor
{
  backColor = [theColor retain];
}

- (void)setYScale:(float)scaleValue
{
	yScale = scaleValue;
	[self display];
}

//THis isn't called by anything!
//Now it is!
-(void)drawLadder:(NSRect)aRect
{
    int					lcount;
    NSColor     *tempColor;
    Gaussian    *current;
    EventLadder *ladder;
    NSRect			selfrect = [self bounds];
    int					start,end, dstart, dend;
    int					i,j;
    float				yscale;
    float				tempoffset=0.0, tempheight=0.0;
    int					viewType;
		NSString		*annotation;
		NSMutableDictionary *stringAttributes;
		NSFont			*tempFont;
  
    ladder = [seqEditor currentLadder];
    if (ladder == nil) return;
    start = ((aRect.origin.x / xScale) + startPoint)-1;
    end = (((aRect.origin.x + aRect.size.width)/xScale) + 		
            startPoint)+1;
    if (start < startPoint)
      start = startPoint;
    if (end > endPoint)
      end = endPoint;
    lcount = [ladder count];
		tempFont = [NSFont fontWithName:@"Arial" size:9];
		stringAttributes= [NSMutableDictionary dictionaryWithObjectsAndKeys:tempFont, NSFontAttributeName, nil];
    viewType = [[[NSUserDefaults standardUserDefaults] objectForKey:@"SplitView"] intValue];
    for (i = 0; i < lcount; i++) {
      current = [ladder objectAtIndex:i];
      if ((([current startExtent] < end) && ([current endExtent] > start)) && 
          ([seqEditor channelEnabled:[current channel]])) {
        
        NSBezierPath *path = [NSBezierPath bezierPath];
        NSPoint p;

        [path setLineWidth:3];
        dstart = (((int)[current startExtent]-1) < start ? start : ((int)[current startExtent]));
        dend = (((int)[current endExtent]+1) > end ? end : ((int)[current endExtent]));
        tempColor = [seqEditor channelColor:[current channel]];
        [tempColor set];
        if ((maxY[[current channel]] - minY[[current channel]])< 1.0e-6)
          yscale = 1.0;
        else
          yscale = (selfrect.size.height-(1.0+yOrigin))/(maxY[[current channel]] -
                                                        minY[[current channel]]);
        if (yScale >= 0)
          yscale = yscale * yScale;
        if (yscale <= 0.0)
          return;
        switch (viewType) {
          case 2:   //all
            tempoffset = 0;
            tempheight = 0;
            break;
          case 1:		//dual
            if ([current channel] > 1) {
              tempoffset = 0;
              tempheight = selfrect.size.height/2;
            }
            else {
              tempoffset = selfrect.size.height/2;
              tempheight = 0;
            }
            break;
          case 0:  //single
            tempoffset = (selfrect.size.height/4)*(3-[current channel]);
            tempheight = (selfrect.size.height/4)*([current channel]);
            break;
        }
        
        p.x = ((dstart-startPoint) * xScale);
        p.y = (([current valueAt:(float)dstart] - minY[[current channel]]) * yscale + yOrigin) + tempoffset;
        [path moveToPoint:p];
        for (j = (dstart+1); j <= dend; j++) {
          p.x = ((j-startPoint)*xScale);
          p.y = (([current valueAt:(float)j] - minY[[current channel]]) * yscale + yOrigin) + tempoffset;
          [path lineToPoint:p];
        }
				[path stroke];

				annotation = [current annotation];
				if (annotation != nil) {
					p.x = ([current center]-startPoint)*xScale;
					if ([current channel]%2==0)
						p.y = yOrigin - 0.5*BASEFONTSIZE - 5;
					else
						p.y = yOrigin - BASEFONTSIZE - 8;
					p.x -= 5.5;
					[stringAttributes setObject:[NSColor blackColor] forKey:NSForegroundColorAttributeName];
					[annotation drawAtPoint:p withAttributes:stringAttributes];
				}
			}
    }
}


- (void)drawRect:(NSRect)aRect
{
  NSRect      selfrect, tempRect;
  Trace       *traceData = [seqEditor pointStorageID];
  NSBezierPath *oPath = [NSBezierPath bezierPath];  //path for misc drawing
  NSPoint op;  //Temp Point
  NSPoint curpoint;
  int         markType;
  
  [NSBezierPath setDefaultLineWidth:1.0];
  [[NSColor whiteColor] set];
  NSRectFill(aRect);
  if (!traceData)
    return;
  selfrect = [self bounds];
  [[NSColor blackColor] set];
  [NSBezierPath strokeRect:selfrect];
  
  if([[NSGraphicsContext currentContext] isDrawingToScreen]) {
     /***
     **** draws highlighted selection in lightGrey
     ***/
    tempRect = NSIntersectionRect(selectRect, aRect);
     if(!NSIsEmptyRect(tempRect)) {
       //just draw the selectRect
       [[NSColor lightGrayColor] set];
       NSRectFill(tempRect);
     }

     /***
     **** draws highlighted base in gray
     ***/
     tempRect = NSIntersectionRect(highlightedBaseRect, aRect);
     if(!NSIsEmptyRect(tempRect)) {
       //just draw the highlightedBaseRect
       [[NSColor darkGrayColor] set];
       NSRectFill(tempRect);
     }

     /***
     **** draws trackline in litegray, unless overlaps selection
     ***/
     if(lastTrackLine != -1) {
       if(!NSIsEmptyRect(NSIntersectionRect(trackRect, aRect))) {
         //trackline is in this displayRect
         if(!NSIsEmptyRect(NSIntersectionRect(trackRect, selectRect))  &&
            !NSEqualRects(trackRect, selectRect)) {
           //trackline overlaps selection so draw it in background
           [backColor set];
           [oPath setLineWidth:1.0];
           op.x = lastTrackLine; op.y = 0;
           [oPath moveToPoint:op];
            op.y = selfrect.size.height;
            [oPath lineToPoint:op];
        }
         else {
           //just draw the trackline
            [[NSColor lightGrayColor] set];
           
            [oPath setLineWidth:1.0];

            op.x = lastTrackLine; op.y = 0;
            [oPath moveToPoint:op];
            op.y = selfrect.size.height;
            [oPath lineToPoint:op];
         }
       }
     }
   }
  NS_DURING
    [self scaleSelftoFitView];

    [self drawWithBezier:aRect];
		
		[self drawBases:xScale :(startPoint + aRect.origin.x/xScale) 
									 :(startPoint + (aRect.origin.x + aRect.size.width)/xScale) :[traceData numChannels] :yOrigin];
    [self drawPhredCalls:xScale :(startPoint + aRect.origin.x/xScale) :(startPoint + (aRect.origin.x + aRect.size.width)/xScale) :yOrigin - 8];
		
    [self drawPeaks:aRect];
    [self drawLadder:aRect];

    if(([[NSGraphicsContext currentContext] isDrawingToScreen]) ||
       (([[[NSUserDefaults standardUserDefaults] objectForKey:@"PrintPointMarks"] intValue]) == 1)) {
      markType = [[[NSUserDefaults standardUserDefaults] objectForKey:@"DataMarker"] intValue];
      if (markType == 0) {
        [self drawDataMarkers:[traceData deleteOffset]];
      }
      else {
        if(![self drawBaseNumbers])
          [self drawDataMarkers:[traceData deleteOffset]];
      }
    }
		
    NS_HANDLER
      tempRect = [self frame];
      NSLog(@"Problem drawing trace because of exception %@",
            localException);
    NS_ENDHANDLER

    if([[NSGraphicsContext currentContext] isDrawingToScreen]) {
        NSBezierPath *seg = [NSBezierPath bezierPath];
        NSPoint p;
        float yscale;
        /***
        **** draws shiftsegment if enabled
        ***/
        if(lastShiftX != -1.0) {
                /* then draw a new one */
            NSColor     *tempColor;
 //           float       red,green,blue, yscale;
            int start=[self pointNumber:(startX-100.0)];
            int end=[self pointNumber:(startX+100.0)];
            int drawstart=[self pointNumber:(lastShiftX-100.0)];
            int i;
    
            tempColor = [seqEditor channelColor:segChannel];
            [tempColor set];
            yscale = (selfrect.size.height-(1.0+yOrigin))/(maxY[segChannel] - minY[segChannel]) ;
            if (yscale <= 0.0) return;
						if (yScale >= 0)
							yscale = yscale * yScale;
            if (start < 0) start = 0;
            if (end > [traceData length])
            end = ([traceData length] - 1);
            p.x = (float)(drawstart-startPoint) * xScale;
            p.y = ([traceData sampleAtIndex:start channel:segChannel]-minY[segChannel]) * yscale + yOrigin;
            [seg moveToPoint:p];
            for (i=0; i <=(end-start); i++)
            {
                p.x = (float)((drawstart+i)-startPoint) * xScale;
                p.y = ([traceData sampleAtIndex:(start + i) channel:segChannel]-minY[segChannel]) * yscale + yOrigin;
                [seg lineToPoint:p];
                            }
            [seg stroke];
        }
    }

    
    [[NSColor blackColor] set];
    [oPath setLineWidth:1];
    curpoint.x = 0; curpoint.y = yOrigin;
    [oPath moveToPoint:curpoint];
    curpoint.x = selfrect.size.width; curpoint.y = yOrigin;
    [oPath lineToPoint:curpoint];
    [oPath stroke];
}

- (void)drawWithBezier:(NSRect)aRect
{
    Trace *trace = [seqEditor trace];
    unsigned    channel;
    NSPoint pt;
    float       bbox[4], yscale, tempoffset=0, tempheight=0; 
    NSRect      selfrect = [self bounds];
    int         viewType;


    if (trace == NULL)
        return;
      
      bbox[0] = selfrect.origin.x;
      bbox[1] = selfrect.origin.y;
      bbox[2] = selfrect.origin.x+selfrect.size.width;
      bbox[3] = selfrect.origin.y+selfrect.size.height;
    
      viewType = [[[NSUserDefaults standardUserDefaults] objectForKey:@"SplitView"] intValue];
    for (channel = 0; channel < [trace numChannels]; channel ++)
        if ([seqEditor channelEnabled:channel]) {
            int start, end, i;
            NSBezierPath *path = [NSBezierPath bezierPath];
            [path setLineWidth:1];

            [[seqEditor channelColor:channel] set];

            start = ((aRect.origin.x / xScale) + startPoint)-1;
            end = (((aRect.origin.x + aRect.size.width)/xScale) + 		
                    startPoint)+1;
            if ((maxY[channel] - minY[channel])< 1.0e-6)
                yscale = 1.0;
            else
                yscale = (selfrect.size.height-(1.0+yOrigin))/(maxY[channel] -
                                                            minY[channel]);
            if (yscale <= 0.0)
                return;
        
						if (yScale >= 0)
							yscale = yscale * yScale;
						
            if (start < 0) start = 0;
            if (end > [trace length]) end = ([trace length] - 1);
        
            pt.x = (float)(start-startPoint) * xScale;
            while (pt.x < bbox[0]) {
                start += 1;
                pt.x = (float)(start-startPoint) * xScale;
            }
						switch (viewType) {
							case 2:   //all
								tempoffset = 0;
								tempheight = 0;
								break;
							case 1:		//dual
								if (channel > 1) {
									tempoffset = 0;
									tempheight = selfrect.size.height/2;
								}
								else {
									tempoffset = selfrect.size.height/2;
									tempheight = 0;
								}
								break;
							case 0:  //single
								//tempheight = tempoffset;
                if (channel > 3) {
                  tempoffset = 0;
                  tempheight = 0;
                }
                else {
                  tempoffset = (selfrect.size.height/4)*(3-channel);
                  tempheight = (selfrect.size.height/4)*(channel);
                }
                break;
						}
							
            pt.y = (float)(([trace sampleAtIndex:start channel:channel]-minY[channel])*yscale + yOrigin + tempoffset);
            if(pt.y < bbox[1]) pt.y=bbox[1];
            if(pt.y > bbox[3]-tempheight) pt.y=bbox[3]-tempheight;
            [path moveToPoint:pt]; 
        
        
            for (i = start; i <= end; i++) {
                pt.x = (float)(i-startPoint) * xScale;
                pt.y = (float)(([trace sampleAtIndex:i channel:channel]-minY[channel]) * yscale + yOrigin + tempoffset);
                if (!((pt.x < bbox[0]) || (pt.x > bbox[2]))) {
                if(pt.y < bbox[1]) pt.y=bbox[1];
                if(pt.y > bbox[3]-tempheight) pt.y=bbox[3]-tempheight;
                [path lineToPoint:pt]; 
                }
        
            }
            [path stroke];
    
    }
}


- (void)setOrigin:(float)x :(float)y
{
	xOrigin = x;
	yOrigin = y; 
}

- (void)setMin:(float*)min Max:(float*)max
{
	/* the range of y data values which are to be displayed in this view */
	int			j;
	int			c = [seqEditor numberChannels];
	
	for (j = 0; j < c; j++) {
		minY[j] = min[j];
		maxY[j] = max[j];
	} 
}

- (BOOL)scaleSelftoFitView
{  
/** the purpose of this function is to set xScale **/
	NSRect 				selfBounds;
	
	if (endPoint - startPoint <= 0) return NO;
	selfBounds = [self bounds];

	xScale = (selfBounds.size.width)/(endPoint - startPoint + 1);			return YES;

}


- (void)setRange:(int)start :(int)end
{
	startPoint = start;
	endPoint = end;
	if(startPoint < 0) startPoint=0; 
}


- (void)setSeqEditor:(id)editor
{
  seqEditor = editor;
}

- (void)selectRegion:(float)from :(float)to
{
  float tmp;
  NSRect newRect, diffRect, oldSelect;

  oldSelect = selectRect;
  if (to<from) { // just in case..
    tmp = to;
    to = from;
    from = tmp;
  }

  newRect = [self bounds];

  if ((to<[self bounds].origin.x && from < [self bounds].origin.x) ||
      (to>[self bounds].origin.x + [self bounds].size.width &&
       from>[self bounds].origin.x + [self bounds].size.width)) // no new highlight
    newRect.size.width = 0.0; // for next time
  else {
    if (from > newRect.origin.x) {
      newRect.size.width -= from - newRect.origin.x;
      newRect.origin.x = from;
    }
    if (to < newRect.origin.x + newRect.size.width)
      newRect.size.width = to - newRect.origin.x;
    if (newRect.size.width==0)
      newRect.size.width=1.0;
  }

  // A common case is for the new and old selections to share an endpoint;
  // if this is the case, just (un)highlight the difference
  if (newRect.size.width > 0 && selectRect.size.width > 0 &&
      (newRect.origin.x == selectRect.origin.x ||
       newRect.origin.x + newRect.size.width == selectRect.origin.x + selectRect.size.width)) {
    diffRect = newRect;
    if (newRect.origin.x == selectRect.origin.x) {
      if (newRect.size.width>selectRect.size.width) {
        diffRect.origin.x += selectRect.size.width;
        diffRect.size.width -= selectRect.size.width;
      } else {
        diffRect.origin.x += newRect.size.width;
        diffRect.size.width = selectRect.size.width - newRect.size.width;
      }
    } else {
      if (newRect.origin.x > selectRect.origin.x) {
        diffRect.origin.x = selectRect.origin.x;
        diffRect.size.width = newRect.origin.x - selectRect.origin.x;
      } else {
        diffRect.origin.x = newRect.origin.x;
        diffRect.size.width = selectRect.origin.x - newRect.origin.x;
      }
    }
    selectRect = newRect;
    [self displayRect:diffRect];
  } else { // otherwise unhighlight the old an highlight the new
    selectRect = newRect;
    if (oldSelect.size.width>0)
      [self displayRect:oldSelect]; // undo previous highlight, if there was one
    if (newRect.size.width>0)	
      [self displayRect:newRect];
  }

  selectRect = newRect;
}


- (void)hideChannel:(int)channel
{
  [seqEditor setEnabled:NO channel:channel];
  [self display];
}

- (void)showChannel:(int)channel
{
  [seqEditor setEnabled:YES channel:channel];
  [self display];
}

- (void)initSegment:(int)channel at:(float)thisX
{
  segChannel = channel;
  lastShiftX = thisX;
  startX = thisX;
}


- (void)drawShiftSegment:(float)thisX
{
  /* 3-31-97 Jessica: redid routine for openstep.  No longer using background
  image.  Do drawing in the drawRect: method. Just setup here, and call a display.
  */

  lastShiftX = thisX;
  if(lastShiftX != -1.0) {
    [self display];
  }
}

- (void)highlightBaseAt:(int)pointLoc
{
  NSRect 	tempRect;

  if(pointLoc == lastHighlightBase) return;
  if((pointLoc < startPoint) || (pointLoc > endPoint)) {
    highlightedBaseRect = NSMakeRect(0, 0, 0, 0);
    [self setNeedsDisplay:YES];
    return; 
  }

  tempRect.origin.x = (pointLoc-startPoint)*xScale-3.0;
  tempRect.origin.y = 0.0;
  tempRect.size.height = yOrigin;
  tempRect.size.width = 5.0;

  highlightedBaseRect = tempRect;

  [self setNeedsDisplay:YES];
  lastHighlightBase = pointLoc;
}

- (void)trackLineAt:(int)thisX
{	
  // The NXEqualRect calls are to keep the track line from obliterating the
  // selection when they overlap exactly--when the selection is wider than
  // one point, just let the track line be white against the selection
  trackRect = [self bounds];
  if (thisX<trackRect.origin.x || thisX > trackRect.origin.x + trackRect.size.width - 1)
    thisX = -1;
  if (lastTrackLine!=-1) {
    //undraw the last trackline
    trackRect.origin.x = lastTrackLine;
    trackRect.size.width = 1.0;
    lastTrackLine = -1;
    [self displayRect:trackRect];
  }
  if (thisX!=-1) {
    //draw the new trackline
    trackRect.origin.x = thisX;
    trackRect.size.width = 1.0;
    lastTrackLine = thisX;
    [self displayRect:trackRect];
  }
  lastTrackLine = thisX;
}

- (int)pointNumber:(float)x
{
	NSRect  tempRect;
	float		width;
	int			point;
	/* converts an x screen location to point number for the pointList */
	
	tempRect = [self bounds];
	width = tempRect.size.width;
	if(x>=(width-1.0)) {
		point=endPoint;
	}
	else {
		if (x<0) x = tempRect.origin.x;
		point = (int)((float)startPoint + 0.5 + (x*(endPoint-startPoint+1))/width);
		if(point<startPoint) point=startPoint;
		if(point>endPoint) point=endPoint;
	}
	return point;
}

- (float)dataPosToViewPos:(int)dataPos
{
	float		value=0.0;
	NSRect  tempRect;
	float		width;
	
	if(dataPos<startPoint || dataPos>endPoint) return -1.0;
	tempRect = [self bounds];
	width = tempRect.size.width;
	value = (dataPos - startPoint)*width/(endPoint-startPoint+1);
	return value;
}

- (BOOL)acceptsFirstMouse:(NSEvent *)theEvent
{
	return YES;
}

- (void)dealloc
{
	[handleImage release];
	[handleImage2 release];
  [super dealloc];
}

@end
