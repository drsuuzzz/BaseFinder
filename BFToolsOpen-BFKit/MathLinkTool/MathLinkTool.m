/***********************************************************

Copyright (c) 1997-2000 Morgan Giddings, Jessica Severin, and Lloyd Smith 

All Rights Reserved.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation. 

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.  Citations, discussions, and references to or regarding
this work in scholarly journals or other scholarly proceedings 
are exempted from this permission requirement.

Support for this work provided by:
The University of Wisconsin-Madison Chemistry Department
The National Institutes of Health/National Human Genome Research Institute
The Department of Energy


******************************************************************/

/* Generated by Interface Builder */

#import "MathLinkTool.h"
#import <GeneKit/MGNSMutableData.h>
#import "MathServer.h"
//#include <bsd/libc.h>

/*****
2/1/97 MG Created from bits and pieces all over the place
******/

@implementation MathLinkTool

- init
{
    hostName = NULL;
    connection = NULL;
    remoteMathServer = NULL;
    preloadName = NULL;
    mathServerTask = NULL;
    serverExecutablePath = NULL;
    
    connected = NO;

    self = [super init];
    return self;	
}

-(void)setExpression:(NSString *)expr
{
    if (expression != NULL)
        [expression release];
    expression = [expr retain];
}

- (void)disconnect
{
    fprintf(stderr, "Disconnecting\n");
    if (connected) {
        [remoteMathServer release];
        remoteMathServer = NULL;
        [connection release];
        connection = NULL;
        if (mathServerTask) {
            [mathServerTask terminate];
            [mathServerTask release];
            mathServerTask = NULL;
        }    
        connected = NO;
    }
}

-(void)setHost:(NSString *)hostname
{
    if (hostName) {
        if (connected && [hostname compare:hostName]) {
            fprintf(stderr, "Old: %s New: %s\n", [hostName cString], [hostname cString]);
            [self disconnect];
        }
            [hostName release];
    }
    hostName = [hostname retain];
}

-(void)setPreloadName:(NSString *)preload
{
    if (preloadName) {
        if (connected && [preload compare:preloadName])
            [self disconnect];
        [preloadName release];
    }
    preloadName = [preload retain];
}

-(void)setServerExecutablePath:(NSString *)path
{
    if (serverExecutablePath) {
        if (connected && [serverExecutablePath compare:path])
            [self disconnect];
        [serverExecutablePath release];
    }
    serverExecutablePath = [path retain];
}


- (NSString *)hostname{
    return hostName;
}

-(NSString *)expression
{
    return expression;
}

- (NSString *)preloadName
{
    return preloadName;
}

- (NSString *)serverExecutablePath {
    return serverExecutablePath;
}

- (void)connectionDidDie:(NSNotification *)notification
{
    fprintf(stderr, "Received connection died notification in MathLink\n");
    if (connection == [notification object]) {
        fprintf(stderr, "Releasing connection object\n");
        [remoteMathServer release];
        remoteMathServer = NULL;
        connected = NO;
    }
}


- (void)connect
{
	NSString *extension;
	
	if (!connected) 
	{
		if (!launchServer) {
			if (!(connected = [self connectToLaunchedServer]))
				connected = [self launchAndConnect];
		}
		else 
			connected = [self launchAndConnect];
		
		if (connected) {
			// [remoteMathServer setProtocolForProxy:@protocol(MathServerProtocol)];
			fprintf(stderr, "Connected, ready and waiting.\n");
			//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(connectionDidDie:) name:NSConnectionDidDieNotification object:connection];
			if (usePreload) {
				extension = [preloadName pathExtension];
				if (![extension compare:@"nb"])
					[remoteMathServer loadNotebook:preloadName];
				else if (![extension compare:@"ma"])
					[remoteMathServer loadPackage:preloadName];
			}
		}
		else
		{
			fprintf(stderr, "Server not connected to mathematica.  Failed.\n");
			[connection release];
			[remoteMathServer release];
		}
	} 
	else
		fprintf(stderr, "Already connected to server!\n");
}

- (BOOL)connectToLaunchedServer
{
    fprintf(stderr, "MathLinkTool: Attempting to connect to existing server on host: %s. . . ", [hostName cString]);

	remoteMathServer = [MathServer ServerConnect:@"BaseFinder" portNo:8000];
    if (remoteMathServer == nil) {
        fprintf(stderr, "Failed to get proxy!!!\n");
        return NO;
    }
    else {
        fprintf(stderr, "Got proxy, connected.\n");
        return [remoteMathServer connected];
    }
    return connected;
} 

- (BOOL)launchAndConnect
{
//    unsigned i;
	NSString *localName = [[NSProcessInfo processInfo] hostName];
	/*    NSString *serverObjName = [[NSProcessInfo processInfo] globallyUniqueString];
    [[NSConnection defaultConnection] setRequestTimeout:240];
    [[NSConnection defaultConnection] setReplyTimeout:240];

    fprintf(stderr, "Local host name: %s\n", [localName cString]);
    fprintf(stderr, "Remote host name: %s\n", [hostName cString]);
    if (mathServerTask) {
        [mathServerTask terminate];
        [mathServerTask release];
    } */
	
    if (hostName && (![hostName compare:@""] || ![hostName compare:localName])) {
        fprintf(stderr, "Launching local server.\n");
			remoteMathServer = [[MathServer ServerLaunchMathConnection:@"BaseFinder" KernelPath:@"/Applications/Scientific/Mathematica 5.0.app/Contents/MacOS/MathKernel"] retain];
			
			/*
			mathServerTask = [NSTask launchedTaskWithLaunchPath:serverExecutablePath  arguments:[[[NSArray alloc] initWithObjects:@"-standalone", @"-servername", serverObjName,  nil] autorelease]];
    } else
      {
			
				fprintf(stderr, "Launching remote server on host %s\n", [hostName cString]);
        mathServerTask = [NSTask launchedTaskWithLaunchPath:@"/usr/ucb/rsh" arguments:[[[NSArray alloc] initWithObjects:hostName,  serverExecutablePath, @"-standalone", @"-servername", serverObjName,  nil] autorelease]]; */
      }
			 else
			 fprintf(stderr, "Cannot launch remote server, not implemented\n"); 

/*    if (!mathServerTask) {
        return NO;
    }
    else {
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillTerminate:) name:NSApplicationWillTerminateNotification object:[NSApplication sharedApplication]];
      }
    
    if (connection) {
        [connection release];
        connection = NULL;
    } 
    i = 0;
    while (connection == NULL) {
        if ((i % 1000) == 0)
            fprintf(stderr, "Obtaining connection\n");
        connection = [[NSConnection connectionWithRegisteredName:serverObjName
                                                        host:hostName] retain];
        if (i > 20000)
            return NO;
        i += 1;
    }
    [connection setRequestTimeout:240];
    [connection setReplyTimeout:240];
    i = 0;
    if (remoteMathServer) {
        [remoteMathServer release];
        remoteMathServer = NULL;
    }
    while (remoteMathServer == NULL) {
        if ((i % 1000) == 0)
            fprintf(stderr, "Obtaining proxy\n");
        remoteMathServer = [[connection rootProxy] retain];
        if (i > 20000)
            return NO;
        i += 1;
    } */
        fprintf(stderr, "Got launched proxy, connected.\n");
        return (connected = [remoteMathServer connected]);
        
}

- apply
{

    fprintf(stderr, "In MLApply Self: %d connected: %d\n", (int)self, (int)connected);
    if (!connected)
        [self connect];
    if (! connected)
			[NSException raise:@"Cannot Connect Error" format:@"Cannot connect to Mathematica on host: %@"];
		
    fprintf(stderr, "After connecting: %d\n", (int)connected);
    if (dataList)
        [remoteMathServer putTrace:dataList];
    if (baseList)
        [remoteMathServer putSequence:baseList];
    [remoteMathServer evalExpression:[self expression]];
    if (returnTrace)
        dataList = [[remoteMathServer getTrace] retain];
    if (returnSequence)
        baseList = [[remoteMathServer getSequence] retain];
    fprintf(stderr, "After finishing: %d\n", (int)connected);
    return [super apply];
    fprintf(stderr, "After super apply: %d\n", (int)connected);

}


- (BOOL)modifiesData { return YES; }
- (BOOL)shouldCache { return YES; }

- (id)initWithCoder:(NSCoder *)aDecoder
{
    [self setExpression:[aDecoder decodeObject]];
    [self setHost:[aDecoder decodeObject]];
    [self setPreloadName:[aDecoder decodeObject]];
    [aDecoder decodeValuesOfObjCTypes:"cccc", &usePreload, &returnTrace, &returnSequence, &launchServer];
    
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:expression];
    [aCoder encodeObject:hostName];
    [aCoder encodeObject:preloadName];
    [aCoder encodeValuesOfObjCTypes:"cccc", &usePreload, &returnTrace, &returnSequence, &launchServer];
}

- (NSString *)toolName
{
  return @"Mathematica Link";
}

- handleTag:(char *)tag fromArchiver:archiver
{

  return self;
}

- (void)writeAscii:archiver
{
	[super writeAscii:archiver];
}

- (void)beginDearchiving:archiver
{

  [super beginDearchiving:archiver];
}

- copyWithZone:(NSZone *)zone;
{
  MathLinkTool     *dupSelf;

  dupSelf = [super copyWithZone:zone];
  dupSelf -> hostName = [hostName retain];
  dupSelf -> expression = [expression retain];
  dupSelf -> preloadName = [preloadName retain];
  dupSelf -> usePreload = usePreload;
  dupSelf -> returnTrace = returnTrace;
  dupSelf -> returnSequence = returnSequence;
  dupSelf -> launchServer = launchServer;
  //Note that if a copy occurs during an operation, the server could get extremely
  //confused.
  dupSelf -> connected = connected;
  if (connected) {
      dupSelf -> remoteMathServer = [remoteMathServer retain];
      dupSelf -> connection = [connection retain];
      [[NSNotificationCenter defaultCenter] addObserver:dupSelf selector:@selector(connectionDidDie:) name:NSConnectionDidDieNotification object:connection];
  } else {
      dupSelf -> remoteMathServer = NULL;
      dupSelf -> connection = NULL;
  }
  return dupSelf;
}

- (void)dealloc
{
    if (preloadName != NULL) [preloadName release];
    if (hostName != NULL)  [hostName release];
    if (expression) [expression release];
    if (connection) [connection release];
    if (remoteMathServer) [remoteMathServer release];
    if (mathServerTask) {
        [mathServerTask terminate];
        [mathServerTask release];
    }
    if (serverExecutablePath)
        [serverExecutablePath release];
    [super dealloc];
}

- (void)appWillTerminate:(NSNotification *)notification
{
    if (mathServerTask)
        [mathServerTask terminate];
}


@end

@implementation MathLinkToolCtrl

- init
{
    NSDictionary *defaultsDict = [NSDictionary dictionaryWithObjectsAndKeys:
        @"", @"Expression",
        @"*", @"Hostname",
        @"NO", @"UsePreload",
        @"", @"PreloadName",
        @"NO", @"ReturnTrace",
        @"NO", @"ReturnSequence",
        @"NO", @"LaunchServer",
        @"/usr/local/bin/MathServerOpenStep", @"ServerLaunchPath",
        nil];
    MathLinkTool *theTool = (MathLinkTool *)dataProcessor;
    

  [super init];
  [[NSUserDefaults standardUserDefaults] registerDefaults:defaultsDict];

  [dataProcessor setExpression:[[NSUserDefaults standardUserDefaults] objectForKey:@"Expression"]];
  [dataProcessor setHost:[[NSUserDefaults standardUserDefaults] objectForKey:@"Hostname"]];
  [dataProcessor setPreloadName:[[NSUserDefaults standardUserDefaults] objectForKey:@"PreloadName"]];
  [dataProcessor setServerExecutablePath:[[NSUserDefaults standardUserDefaults] objectForKey:@"ServerLaunchPath"]];
  theTool->usePreload = [[NSUserDefaults standardUserDefaults] boolForKey:@"UsePreload"];
  theTool->returnTrace = [[NSUserDefaults standardUserDefaults] boolForKey:@"ReturnTrace"];
  theTool->returnSequence = [[NSUserDefaults standardUserDefaults] boolForKey:@"ReturnSequence"];
  theTool->launchServer = [[NSUserDefaults standardUserDefaults] boolForKey:@"LaunchServer"];
  settingPath = NO;
  return self;
}

- (void)getParams
{
    MathLinkTool *theTool = (MathLinkTool *)dataProcessor;

    [dataProcessor setExpression:[expression string]];
    [dataProcessor setHost:[hostname stringValue]];
    [dataProcessor setPreloadName:[preloadNameID stringValue]];
    [dataProcessor setServerExecutablePath:[launchPathID stringValue]];
    theTool -> usePreload = [usePreloadID state];
    theTool -> returnTrace = [returnTraceID state];
    theTool -> returnSequence = [returnSequenceID state];
    theTool -> launchServer = [launchID state];

    [[NSUserDefaults standardUserDefaults] setObject:[dataProcessor expression] forKey:@"Expression"];
    [[NSUserDefaults standardUserDefaults] setObject:[dataProcessor hostname] forKey:@"Hostname"];
    [[NSUserDefaults standardUserDefaults] setObject:[dataProcessor preloadName] forKey:@"PreloadName"];
    [[NSUserDefaults standardUserDefaults] setObject:[dataProcessor serverExecutablePath] forKey:@"ServerLaunchPath"];
    [[NSUserDefaults standardUserDefaults] setBool:theTool->usePreload forKey:@"UsePreload"];
    [[NSUserDefaults standardUserDefaults] setBool:theTool->returnTrace forKey:@"ReturnTrace"];
    [[NSUserDefaults standardUserDefaults] setBool:theTool->returnSequence forKey:@"ReturnSequence"];
    [[NSUserDefaults standardUserDefaults] setBool:theTool->launchServer forKey:@"LaunchServer"];

}

- (void)displayParams
{
    MathLinkTool *theTool = (MathLinkTool *)dataProcessor;

    [hostname setStringValue:[dataProcessor hostname]];
    [expression setString:[dataProcessor expression]];
    [preloadNameID setStringValue:[dataProcessor preloadName]];
    [launchPathID setStringValue:[dataProcessor serverExecutablePath]];
    [usePreloadID setState:theTool -> usePreload];
    [returnTraceID setState:theTool -> returnTrace];
    [returnSequenceID setState:theTool -> returnSequence];
    [launchID setState:theTool -> launchServer];
}

- (void)setPreloadFile:sender
{
    NSString *file;
    NSArray *fileTypes = [[[NSArray alloc] initWithObjects:@"ma", @"nb",  nil] autorelease];
    NSOpenPanel *openpanel = [NSOpenPanel openPanel];

    settingPath = YES;
    [openpanel setAllowsMultipleSelection:NO];
    if ([openpanel runModalForTypes:fileTypes]) {
        file = [openpanel filename];
        [preloadNameID setStringValue:file];
    }
    settingPath = NO;
}

- (void)setServerExecutablePath:sender
{
    NSString *file;
    NSArray *fileTypes = [[[NSArray alloc] initWithObjects:@"",  nil] autorelease];
    NSOpenPanel *openpanel = [NSOpenPanel openPanel];

    settingPath = YES;
    [openpanel setAllowsMultipleSelection:NO];
    if ([openpanel runModalForTypes:fileTypes]) {
        file = [openpanel filename];
        [launchPathID setStringValue:file];
    }
    settingPath = NO;
}

- (BOOL)inspectorWillUndisplay
{
  if(settingPath) {
    return NO;
  }
  return YES;
}


@end

